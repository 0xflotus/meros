<html>
<body>
<header>
	<meta charset="utf8"/>
</header>
<script type="module">
	//import { meros } from 'https://unpkg.com/meros@1.0.0-beta.5/browser/index.mjs?module';

	const separator = '\r\n\r\n';
	const decoder = new TextDecoder();
	const encoder = new TextEncoder();
	async function* generate(stream, boundary) {
		console.log('boundary', boundary);
		const reader = stream.getReader();
		let buffer = '';
		let last_index = 0;
		let is_preamble = true;
		let is_json = false;
		try {
			outer: while (true) {
				const result = await reader.read();
				if (result.done)
					break outer; // undefined value
				const chunk = decoder.decode(result.value);
				console.log('got chunk', chunk);
				const idx_chunk = chunk.indexOf(boundary);
				let idx_boundary = buffer.length;
				buffer += chunk;
				console.log('idx_chunk things')
				if (!!~idx_chunk) {
					console.log('true idx_chunk');
					// chunk itself had `boundary` marker
					idx_boundary += idx_chunk;
				} else
				{
					console.log('else idx_chunk');
					// search combined (boundary can be across chunks)
					idx_boundary = buffer.indexOf(boundary, last_index);
					if (!~idx_boundary) {
						// rewind a bit for next `indexOf`
						last_index = buffer.length - chunk.length;
						continue;
					}
				}
				console.log(idx_boundary, !!~idx_boundary);
				while (!!~idx_boundary) {
					console.log('while !!~idx_boundary', buffer.substring(0, idx_boundary).toString());
					const current = buffer.substring(0, idx_boundary + boundary.length);
					const next = buffer.substring(idx_boundary + boundary.length);
					console.log('CURRENT');
					console.log(current.toString());
					console.log('CURRENT');
					console.log('NEXT');
					console.log(next.toString());
					console.log('NEXT');
					console.log('BUFFER');
					console.log(buffer.toString());
					console.log('BUFFER');
					if (is_preamble) {
						is_preamble = false;
						buffer = buffer.substring(idx_boundary);
					} else
					{
						console.log('preamble else');
						let ctype = '',clength = '';
						const idx_headers = current.indexOf(separator);
						// parse headers, only keeping relevant headers
						buffer.substring(0, idx_headers).trim().split(/\r\n/).forEach((str, idx) => {
							idx = str.indexOf(':');
							let key = str.substring(0, idx).toLowerCase();
							if (key === 'content-type')
								ctype = str.substring(idx + 1).trim();else
							if (key === 'content-length')
								clength = str.substring(idx + 1).trim();
						});
						let payload = current.substring(idx_headers + separator.length);
						if (clength) {
							const arr = encoder.encode(payload);
							payload = decoder.decode(arr.subarray(0, parseInt(clength, 10)));
						}
						is_json = ctype ? !!~ctype.indexOf('application/json') : is_json;
						console.log('yield');
						yield is_json ? JSON.parse(payload) : payload;
						if (next.substring(0, 2) === '--')
							break outer;
					}
					console.log('after preamble');
					buffer = next;
					last_index = 0;
					idx_boundary = buffer.indexOf(boundary);
					console.log(idx_boundary, !!~idx_boundary);
				}
			}
		} finally
		{
			reader.releaseLock();
		}
	}

	/**
	 * Yield immediately for every part made available on the response. If the `content-type` of the response isn't a
	 * multipart body, then we'll resolve with {@link Response}.
	 *
	 * @example
	 *
	 * ```js
	 * const parts = await fetch('/fetch-multipart')
	 *      .then(meros);
	 *
	 * const parts = await meros(response);
	 *
	 * for await (const part of parts) {
	 *     // do something with this part
	 * }
	 * ```
	 */
	async function meros(response) {
		if (!response.ok || !response.body || response.bodyUsed) {
			// @ts-ignore
			return;
		}
		const ctype = response.headers.get('content-type');
		if (!ctype)
			throw new Error('There was no content-type header');
		if (!/multipart\/mixed/.test(ctype))
			return response;
		const idx_boundary = ctype.indexOf('boundary=');
		return generate(response.body, `--${!!~idx_boundary ?
			// +9 for 'boundary='.length
			ctype.substring(idx_boundary + 9).trim().replace(/['"]/g, '') :
			'-'}`);
	}

	(async () => {
		const response = await fetch('http://localhost:3004/graphql',
			{
				body: JSON.stringify({
					operationName: 'appIndex_Query',
					query: `query appIndex_Query {
  song {
    firstVerse
    ...appIndex_SecondLyric @defer(label: "appIndex_Query$defer$appIndex_SecondLyric")
  }
}

fragment appIndex_SecondLyric on Song {
  secondVerse
}`,
					variables: {},
				}),
				headers: {
					Accept: 'application/json',
					'Content-Type': 'application/json',
				},
				method: 'POST',
			});
		console.log([...response.headers.entries()]);

		console.log('got response');

		/*const reader = await response.body.getReader();

		let done = false;
		while(!done) {
			const result = await reader.read();
			done = result.done;
			const value = result.value;
			console.log(decoder.decode(value));
		}*/

		const parts = await meros(response);

		for await (const part of parts) {
			const { data, path, hasNext, label } = part;
			console.log({
				data,
				path,
				label,
				extensions: {
					is_final: !hasNext,
				},
			});
		}
	})()
</script>
</body>
</html>
